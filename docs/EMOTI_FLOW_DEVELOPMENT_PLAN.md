# EmotiFlow 개발 및 설계/트러블슈팅 가이드 01/21 (Clean Architecture + MVVM)

이 문서는 EmotiFlow 프로젝트의 지속 가능한 개발과 고품질 배포를 위한 설계 원칙, 구현 계획, 그리고 협업 규칙을 정의합니다.

## 📊 구현 현황 요약 (2026-01-21 기준)

### ✅ 완료된 기능
- [x] Domain Layer 구현 (Entities, Repository Interfaces)
- [x] 일부 UseCase 구현 (일기 CRUD 기본 기능)
- [x] Data Layer 구현 (Models, Repository Implementations)
- [x] Gemini AI 프롬프트 시스템 구현 및 최적화
- [x] Firebase Authentication (Google 로그인)
- [x] Firebase Firestore 연동
- [x] 일기 작성/조회/삭제 기본 UI
- [x] AI 채팅 일기 작성 기능
- [x] 감정 선택 및 분석 시스템
- [x] 감정 캐릭터 에셋 준비 (Emoti 및 기타 캐릭터)
- [x] 기본 다크모드 구현
- [x] **감정-캐릭터 매핑 시스템** (`EmotionCharacterMap` 클래스)
- [x] **AI 채팅 UI 전면 개편** (2026-01-21)
  - [x] 감정별 캐릭터 프로필 표시
  - [x] 감정별 배경색 자동 변경
  - [x] 캐릭터 기반 감정 선택 UI (그리드 레이아웃)
  - [x] 말풍선 디자인 개선 (모던한 스타일)
  - [x] 타이핑 인디케이터에 캐릭터 표시
- [x] **UI 가독성 개선** (2026-01-22)
  - [x] AI 채팅 텍스트 입력 필드 색상 진하게
  - [x] 모든 AppBar 제목/아이콘 색상 진하게
  - [x] SafeArea 적용 (일기 작성 페이지)
- [x] **리팩토링 기반 구축** (2026-01-22 오전)
  - [x] 그림 그리기 위젯 분리 준비 (5개 파일)
  - [x] 일기 작성 위젯 분리 준비 (1개 파일)
- [x] **대규모 리팩토링 완료** (2026-01-22 오후) ⚡
  - [x] `drawing_canvas_page.dart` 파일 구조 정리 (폴더 내 이동)
  - [x] `diary_write_page.dart` 위젯 분리 (1005줄 → 500줄, 50% 감소)
    - [x] emotion_selector_section.dart (감정 선택 + 강도)
    - [x] title_input_card.dart (제목)
    - [x] content_input_card.dart (내용)
    - [x] drawing_section_card.dart (그림)
    - [x] settings_section_card.dart (설정)
  - [x] 중복 파일 삭제 (date_selector_card.dart)
  - [x] 린트 오류 해결 (4개 필드 final 변경, debugPrint import)

### 🔄 진행 중인 기능
- [ ] Clean Architecture 완전 전환 (일부 Provider가 아직 직접 Firebase 접근)
- [ ] ViewModel 리팩토링 (Riverpod Notifier 패턴 적용)
- [ ] UseCase 전체 구현 (통계, 필터링, 정렬 등)
- [ ] 라우팅 전수 점검
- [ ] **캐릭터별 AI 말투 차별화** (프롬프트 시스템 확장 - 문서화 진행 중)
- [ ] 감정 선택 UI 공통 위젯화 (EmotionSelectionPage + DiaryWritePage 중복 제거)

### 📝 해야 할 것 (우선순위순)
1. **필수 (즉시 착수)**
   - [ ] 감정 캐릭터 UI 적용 (assets/images/characters/ 활용)
   - [ ] 라우팅 버그 수정 (AI 채팅 일기 → 상세 페이지 이슈)
   - [ ] 다크모드 색상 대비 및 접근성 완성
   - [ ] 테스트 코드 작성 (Domain UseCase 우선)

2. **중요 (단기)**
   - [ ] 감정 통계 대시보드 구현
   - [ ] 감정 시각화 (레이어 캘린더, 스펙트럼 링 등)
   - [ ] 오프라인 지원 (캐시 우선 전략)
   - [ ] 에러 핸들링 및 로깅 체계 구축

3. **보완 (중기)**
   - [ ] BGM 기능 재구현 (자체 음원 라이브러리)
   - [ ] AI 캐릭터 NPC 시스템 (멀티 캐릭터)
   - [ ] 질문 던전 모드 구현
   - [ ] 이메일/비밀번호 로그인 추가
   - [ ] SNS 로그인 확장 (Kakao, Apple)

4. **고도화 (장기)**
   - [ ] 감정 성장 시각화
   - [ ] 감정 회고 카드 자동 생성
   - [ ] 데이터 백업/복구 기능
   - [ ] Flutter Web 배포
   - [ ] CI/CD 파이프라인 구축

### 👤 사용자가 해야 할 작업 리스트
1. **캐릭터 에셋 정리 및 적용**
   - [ ] `assets/images/characters/` 폴더 내 캐릭터 이미지 파일명 정리
   - [ ] 감정별 캐릭터 매핑 테이블 작성 (예: 기쁨 → Emoti3.png)
   - [ ] UI에 캐릭터 이미지 표시 로직 구현 (감정 선택 화면, 일기 상세 등)
   
2. **디자인 및 UX 결정**
   - [ ] 최종 감정 시각화 방식 선택 (레이어 캘린더 vs 스펙트럼 링 vs 성장 그래프)
   - [ ] AI 캐릭터 페르소나 확정 (따뜻한/직설적인/유쾌한 등)
   - [ ] 앱 전체 색상 팔레트 최종 검토 및 다크모드 색상 조정

3. **테스트 및 피드백**
   - [ ] 실제 사용 시나리오 테스트 (일기 작성 → 조회 → 삭제 플로우)
   - [ ] AI 대화 품질 테스트 (다양한 감정 및 상황)
   - [ ] 라우팅 버그 재현 및 보고

## 1. 설계 철학: Clean Architecture + MVVM + Riverpod

현재의 기능을 유지하면서 확장성과 테스트 가능성을 극대화하기 위해 클린 아키텍처를 도입하고, MVVM 패턴과 Riverpod을 결합하여 상태 관리를 체계화합니다.

### 1.1 계층 구조 및 디렉토리 설계

각 기능(feature)은 아래와 같이 3가지 핵심 계층으로 분리됩니다.

```bash
lib/features/diary/
├── domain/                # 핵심 비즈니스 로직 (외부 의존성 없음)
│   ├── entities/          # 순수 Dart 객체 (예: DiaryEntry)
│   ├── repositories/      # 저장소 인터페이스 (abstract class)
│   └── usecases/          # 비즈니스 로직 단위 (예: CreateDiaryUseCase)
├── data/                  # 데이터 소스 및 모델 구현
│   ├── models/            # DTO (Data Transfer Object), JSON/Firestore 매핑
│   ├── repositories/      # domain/repositories의 실제 구현체
│   └── datasources/       # 외부 API(Gemini, Firebase)와 직접 통신
└── presentation/          # UI 및 상태 관리
    ├── viewmodels/        # Riverpod Notifiers (UseCase 호출 및 상태 업데이트)
    ├── views/             # Flutter Widgets & Pages
    ├── states/            # UI 전용 상태 모델
    └── widgets/           # 해당 기능 내에서만 쓰이는 공통 위젯
```

### 1.2 리팩토링 핵심 방향성 (현재 코드의 문제점 및 해결책)

1.  **모델 분리 (Entity vs Model):**
    *   **문제:** 현재 `DiaryEntry`에 Firestore 매핑 로직(`toFirestore`)과 비즈니스 로직(`strongestEmotion`)이 혼재되어 있어 데이터 소스가 변경될 경우 도메인 로직까지 영향을 받음.
    *   **해결:** `domain/entities`에는 순수한 데이터 구조와 비즈니스 로직만 남기고, `data/models`에서 Firestore 특화 로직을 분리함.
2.  **비즈니스 로직의 UseCase화:**
    *   **문제:** `DiaryProvider`가 데이터 조회, 필터링, 정렬 등 너무 많은 책임을 지고 있어 코드가 비대해짐.
    *   **해결:** `GetFilteredDiariesUseCase`, `DeleteDiaryUseCase` 등으로 로직을 파편화하여 가독성과 재사용성을 높임.
3.  **의존성 역전 (Dependency Inversion):**
    *   **문제:** UI나 Provider가 직접 Firebase Firestore 인스턴스에 접근하고 있어 단위 테스트가 어려움.
    *   **해결:** Repository 인터페이스를 두어 구현 세부 사항(Firebase)으로부터 비즈니스 로직을 보호하고, 필요 시 Mock 데이터를 쉽게 주입할 수 있도록 함.

### 1.3 기능 추가 시 가이드라인

새로운 기능(예: '감정 통계')을 추가할 때의 표준 작업 흐름:
1.  **Domain:** 어떤 데이터가 핵심이고(`Entity`), 어떤 비즈니스 규칙이 있는지(`UseCase`) 먼저 정의합니다.
2.  **Data:** 데이터를 어디서 가져올지(`DataSource`), 외부 형식을 엔티티로 어떻게 변환할지(`Model`) 구현합니다.
3.  **Presentation:** UseCase를 호출하여 UI 상태를 관리할 `ViewModel`과 실제 화면인 `View`를 작성합니다.

---

## 2. 기능별 보완 및 구현 방향

### 2.1 Gemini AI 프롬프트 개선 (Point 3)
*   **문제점:** 반복적인 대답, 사용자 질문 무시
*   **개선 방향:**
    1.  **Role Playing 구체화:** "전문적인 심리 상담가"로서의 페르소나 강화
    2.  **Context 주입 방식 변경:** 단순 히스토리 나열이 아닌, 사용자의 '핵심 의도'와 '이전 대화 요약'을 분리하여 주입
    3.  **제약 사항 명시:** "이전 답변과 70% 이상 유사한 문장 사용 금지", "사용자의 마지막 질문에 반드시 먼저 답변할 것" 등의 강력한 지침 추가
    4.  **Few-shot Learning:** 좋은 답변 예시를 프롬프트에 포함하여 품질 상향 평준화

### 2.2 BGM 기능 보완 방향성 (Point 2)
*   **현재 상태:** 비활성화 처리 (불안정한 외부 URL 및 단순 매칭)
*   **향후 보완 방향:**
    1.  **자체 음원 라이브러리:** 저작권 프리 음원을 앱 내 에셋 또는 Firebase Storage에 안정적으로 저장
    2.  **감정-음악 매핑 정교화:** 단순 감정 태그 매칭이 아닌, AI 분석 결과(강도, 분위기)를 활용한 큐레이션
    3.  **오디오 엔진 최적화:** `just_audio` 등을 활용한 끊김 없는 스트리밍 및 페이드 인/아웃 적용

### 2.3 테스트 및 빌드 전략 (Point 6)
*   **Unit Test:** Domain Layer의 UseCase와 비즈니스 로직 테스트
*   **Widget Test:** 주요 UI 컴포넌트 및 Interaction 테스트
*   **Integration Test:** Firebase 및 AI 연동을 포함한 전체 흐름 테스트
*   **부하 테스트(실사용자 가정):** 적정 트래픽을 시뮬레이션하여 안정성/응답성 검증
*   **CI/CD:** GitHub Actions를 활용한 자동 빌드 및 테스트 환경 구축

### 2.4 UI/UX 전면 개편 (추가)
*   **목표:** 현재 UI/UX 구조를 전면 재정비하여 일관된 브랜드 경험 제공
*   **디자인 추천(짧게):** 감정/치유 컨셉에 맞춰 **미니멀 + 소프트 그라데이션 + 라운드 코너** 조합이 적합
*   **감정 이모지/마스코트:** 앱 톤을 강화할 수 있도록 감정 이모지 세트와 마스코트 디자인 방향성 확정
*   **반응형 + 다크모드 기본화:** 모든 페이지에 다크모드/반응형 UI 적용, 모바일·태블릿·웹 모두 정상 동작 보장
*   **폰트 적용 표준화:** 전역 텍스트 스타일(헤드라인/본문/캡션) 확정, 폰트 로딩 및 fallback 전략 정의
*   **터치 영역 보장:** 주요 UI 컴포넌트의 최소 터치 영역(권장 44~48dp) 기준 적용

### 2.5 다크모드 완성 (추가)
*   **현재 상태:** 부분 구현
*   **계획:** 색상 대비 및 접근성 기준에 맞춰 다크모드 완성도 향상

### 2.6 AI 프롬프트 구체화 (추가)
*   **목표:** 상담가 페르소나 강화 + 맥락 요약/의도 분석 강화
*   **추가 방향:** 반복 답변 억제 규칙/롱컨텍스트 최적화 규칙 적용

### 2.7 자체 로그인 + SNS 로그인 추가 (추가)
*   **목표:** 이메일/비밀번호 로그인 + Google/Apple/Kakao 등 소셜 로그인 병행
*   **보안:** OAuth 동의 화면/테스트 사용자 정책 가이드 문서화

### 2.8 라우팅 전수 점검 (즉시 필요)
*   **현황:** AI 채팅 일기 라우팅이 상세 페이지로 연결되는 이슈 발생
*   **계획:** GoRouter 경로 규칙 통일, 모든 navigation 경로 검증 및 테스트 케이스 추가

### 2.9 감정 기록의 시각화 방향성 (추가)
*   **핵심:** 일기는 텍스트 기록에 그치지 않고, 감정이 **보이는 경험**이 되어야 함
*   **아이디어 참고(차별화 전제):**
    *   달력형 감정 배지(출석형)는 활용하되, 단순 이모지 나열 대신 **감정 강도/혼합 비율**을 함께 표현
    *   감정 칵테일/믹스 컨셉은 참고하되, 고유한 시각 언어(예: 감정 레이어/결/결정체)로 변형
*   **제안 컨셉(중복 최소화):**
    1. **감정 레이어 캘린더:** 하루 감정을 ‘층’으로 쌓아 색/투명도/패턴으로 표현
    2. **감정 스펙트럼 링:** 일간 감정을 원형 스펙트럼에 배치해 조합 비율을 시각화
    3. **감정 씨앗 → 성장 그래프:** 기록할수록 감정이 성장/변화하는 시각(식물/결정체)로 누적
*   **목표:** “감정을 기록하면 바로 보인다”는 피드백 루프 제공

### 2.10 AI 경험 차별화 방향 (추가)
*   **문제:** 단순 Q&A 또는 첫 질문 유도만으로는 차별점 약함
*   **제안 방향:**
    1. **감정 회고 카드 생성:** 대화 기반으로 ‘오늘의 한 문장/한 문단 요약’ 카드를 자동 생성
    2. **감정 패턴 안내:** 최근 기록의 패턴을 요약해 “이번 주 감정 흐름”을 짧게 제시
    3. **행동 제안 미션:** 감정에 맞는 1~3개의 짧은 실천 제안(체크리스트 형태)
    4. **대화 자체의 재미 요소(차별화):**
       - **감정 던전(선택형 대화):** 질문에 대한 응답을 선택지+자유 입력 혼합으로 진행
       - **감정 온도계 인터랙션:** 대화 중 실시간으로 감정 강도를 스와이프/슬라이더로 조정
       - **오늘의 감정 NPC:** 요일/상황에 따라 말투와 캐릭터가 바뀌는 대화 파트너
       - **짧은 챌린지 대화:** 3분/5분 타이머 대화 후 핵심 요약(게임성)
    5. **구체화 아이디어 (NPC/질문 던전):**
       - **멀티 캐릭터 NPC:** 3~5종 캐릭터(따뜻한/직설적인/유쾌한/차분한) 프로필 고정
         - 세션 시작 시 캐릭터 선택, 대화 중 캐릭터 교체 가능
         - 캐릭터별 고유 프롬프트(말투/문장 길이/이모지 스타일) 적용
       - **질문 던전(질문 카드 선택):**
         - 한 턴에 3~5개 질문 카드 제시 → 사용자가 골라 진행
         - 카드에는 난이도/깊이 표시(가벼움/보통/깊음)
         - 선택에 따라 분기되는 후속 질문(간단한 트리 구조)
*   **목표:** “대화 결과가 기록/시각화로 남는 경험”을 제공

### 2.11 AI 롤아웃/과금 전략 (추가)
*   **초기 전략:** 출시 초기는 **기본 대화 기능만 제공**하여 안정성/품질 확보
*   **운영 방침:** 개발 직후에는 **무료 제공**, 실제 사용량/비용 지표를 보고 정책 결정
*   **확장 타이밍:** 데이터가 쌓이면 캐릭터/던전 모드 등 고급 기능을 단계적으로 활성화

### 2.12 캐릭터 시스템 UI 적용 (신규 추가)
*   **목표:** 대표 캐릭터 Emoti와 감정별 캐릭터들을 UI에 통합하여 브랜드 아이덴티티 강화
*   **현황:**
    *   캐릭터 에셋: `assets/images/characters/` 폴더에 준비됨
    *   Emoti.png: 앱 로고로 이미 적용됨
    *   감정별 캐릭터 이미지: 준비 완료, UI 적용 대기 중
*   **구현 계획:**
    1.  **감정-캐릭터 매핑 시스템:**
        ```dart
        // lib/shared/constants/emotion_character_map.dart
        class EmotionCharacterMap {
          static const Map<String, String> characterAssets = {
            '기쁨': 'assets/images/characters/joy_character.png',
            '슬픔': 'assets/images/characters/sad_character.png',
            '분노': 'assets/images/characters/anger_character.png',
            // ... 나머지 감정들
          };
          
          static String getCharacterAsset(String emotion) {
            return characterAssets[emotion] ?? 
                   'assets/images/characters/Emoti.png'; // 기본 캐릭터
          }
        }
        ```
    2.  **UI 적용 지점:**
        *   감정 선택 화면: 각 감정 버튼에 해당 캐릭터 미니 아이콘 표시
        *   AI 채팅 화면: 선택한 감정의 캐릭터를 AI 메시지 옆에 표시
        *   일기 상세 화면: 주요 감정의 캐릭터를 헤더에 표시
        *   감정 통계 화면: 가장 많이 느낀 감정의 캐릭터를 강조 표시
    3.  **애니메이션 및 인터랙션:**
        *   캐릭터 등장 시 페이드인 애니메이션
        *   감정 강도에 따라 캐릭터 크기 변화
        *   탭 시 캐릭터 반응 애니메이션 (선택적)
*   **이미지 최적화:**
    *   PNG 파일 압축 (TinyPNG 등 활용)
    *   WebP 포맷 전환 고려 (Flutter 3.0+ 지원)
    *   적절한 해상도 설정 (1x, 2x, 3x)
*   **접근성 고려:**
    *   캐릭터 이미지에 Semantics 레이블 추가
    *   색각 이상자를 위한 대체 표현 병행

---

## 3. 플랫폼 확장: Flutter Web 전략

현재 프로젝트의 생산성을 극대화하기 위해 Flutter Web을 통한 멀티 플랫폼 배포를 진행합니다.

### 3.1 웹 구현 전략
1.  **코드 재사용:** Domain 및 Data 계층의 로직을 100% 공유하여 개발 속도 확보
2.  **반응형 디자인:** `LayoutBuilder`를 활용하여 모바일/태블릿/웹 환경에 대응하는 UI/UX 설계
3.  **웹 전용 최적화:** 
    *   Firebase Web SDK 연동 및 설정 최적화
    *   브라우저 렌더링 방식(Canvaskit vs HTML) 선택을 통한 성능 및 폰트 최적화

### 3.2 웹 배포 프로세스
*   **Build:** `flutter build web --release`
*   **Hosting:** Firebase Hosting을 통한 안정적인 웹 서비스 제공

---

## 4. 코딩 원칙 및 가이드라인 (중요: 모든 작업 시 준수)

지속 가능한 프로젝트 관리를 위해 모든 코드 작성 및 리팩토링 시 아래 원칙을 **무조건** 준수합니다.

---

## ⚠️ **코드 작성 전 필수 체크리스트** (매번 확인!)

**모든 코드 작성/수정 전 다음을 확인하세요:**

### 📋 **사전 점검 (Before Coding)**
- [ ] 이 기능/수정이 기존 코드와 중복되지 않는가?
- [ ] 위젯을 분리할 수 있는가? (파일이 200줄 이상이면 분리 고려)
- [ ] 공통 위젯/서비스로 추출할 수 있는가?
- [ ] Clean Architecture 계층 구조를 지키는가?

### ✅ **코드 작성 중 (During Coding)**
- [ ] const 생성자를 최대한 사용하는가?
- [ ] 의미 있는 변수명/함수명을 사용하는가?
- [ ] 복잡한 로직에 주석을 추가했는가?
- [ ] 에러 핸들링이 포함되어 있는가?

### 🔍 **코드 완성 후 (After Coding)**
- [ ] 파일 크기가 300줄을 넘지 않는가?
- [ ] 린트 에러가 없는가?
- [ ] 중복 코드가 없는가?
- [ ] 문서(daily_logs) 업데이트를 했는가?

**🚨 하나라도 위반 시 즉시 리팩토링!**

---

### 4.1 중복 배제 및 재사용성 (DRY - Don't Repeat Yourself)
*   새로운 기능을 추가하거나 코드를 수정하기 전, **이미 동일하거나 유사한 기능을 수행하는 코드가 있는지 반드시 확인**합니다.
*   공통 로직은 `shared/utils`나 `core` 계층으로 추출하고, 중복 코드는 발견 즉시 제거합니다.

### 4.2 위젯 분리 및 구조화
*   한 파일의 코드 길이가 지나치게 길어지는 것을 방지합니다. (권장: Widget 파일당 200~300라인 이하)
*   UI 구성 요소는 작은 단위의 위젯으로 분리하여 `features/기능/presentation/widgets` 또는 `shared/widgets`에 관리합니다.
*   **관심사 분리:** View는 UI 표현에만 집중하고, 모든 상태 변화와 로직은 ViewModel(Notifier)과 UseCase에서 처리합니다.

### 4.3 가독성 및 유지보수성
*   의미 있는 변수명과 함수명을 사용하며, 복잡한 로직에는 반드시 설명 주석을 추가합니다.
*   클린 아키텍처의 계층 간 경계를 엄격히 지켜, 특정 계층의 변경이 다른 계층에 미치는 영향을 최소화합니다.

### 4.4 성능 및 메모리 최적화
*   **Const 생성자 활용:** 가능한 모든 곳에서 `const` 생성자를 사용하여 컴파일 타임 상수를 정의하고 불필요한 위젯 리빌드 및 메모리 할당을 방지합니다.
*   **이미지 최적화:** 네트워크 이미지 로딩 시 캐싱 처리와 리사이징을 고려합니다.

### 4.5 오프라인/저신호 대응 전략
*   **캐시 우선 전략:** 최근 조회 데이터(일기 목록/상세) 로컬 캐시 우선 제공
*   **네트워크 상태 감지:** 연결 상태 변화 시 UI에 명확한 안내 배너 표시
*   **요청 재시도 정책:** 일정 횟수/지수 백오프 방식으로 재시도, 실패 시 명확한 오류 메시지 제공
*   **쓰기 동기화 큐:** 오프라인 작성 일기 임시 저장 후 네트워크 복구 시 자동 동기화

### 4.6 관측/로그/모니터링/에러 대응
*   **크래시 리포팅:** 앱 크래시 자동 수집 및 알림 체계 구축
*   **로그 구조화:** 사용자 플로우(로그인/작성/저장) 중심 구조화 로그 수집
*   **성능 모니터링:** 앱 시작 시간/탭 전환 지연/네트워크 지연 지표 추적
*   **오류 대응 정책:** 사용자에게는 간결한 메시지, 내부에는 상세 원인 로깅

### 4.7 Gemini 프롬프트 관리 원칙
*   **중앙화된 관리:** 모든 프롬프트는 `gemini_service.dart`에 집중 관리
*   **버전 관리:** 프롬프트 변경 시 `docs/gemini_prompts_guide.md`에 히스토리 기록
*   **테스트 및 검증:**
    *   새 프롬프트 적용 전 최소 5개 이상의 다양한 시나리오로 테스트
    *   응답 길이, 톤, 반복 여부, 맥락 유지 등 체크리스트 확인
*   **Fallback 전략:** API 키 없음/네트워크 오류 시 자연스러운 대체 응답 제공
*   **사용자 피드백 반영:** 실제 사용자 반응을 바탕으로 지속적으로 개선

### 4.8 에셋 관리 규칙
*   **폴더 구조 엄수:**
    ```
    assets/
    ├── images/
    │   ├── characters/      # 캐릭터 이미지 (Emoti 포함)
    │   ├── emotions/        # 감정별 아이콘/일러스트
    │   ├── backgrounds/     # 배경 이미지
    │   └── icons/           # 앱 내 아이콘
    ```
*   **파일명 규칙:**
    *   소문자 + 언더스코어 사용 (`emoti_happy.png`)
    *   감정명은 영문 또는 한글 통일 (예: `joy_character.png` 또는 `기쁨_캐릭터.png`)
*   **이미지 최적화:**
    *   PNG는 TinyPNG 등으로 압축 후 커밋
    *   큰 이미지(>500KB)는 WebP 전환 고려
    *   불필요한 메타데이터 제거
*   **pubspec.yaml 업데이트:**
    *   새 에셋 폴더 추가 시 반드시 `pubspec.yaml`에 등록
    *   변경 후 `flutter pub get` 실행 확인

### 4.9 Git 커밋 및 브랜치 전략
*   **일일 개발 로그 작성:**
    *   파일: `docs/daily_logs/YYYY-MM-DD.md` (예: `2026-01-21.md`)
    *   작성 시점: 커밋 전 (커밋 메시지 참고용)
    *   내용: 완료된 기능, 수정 파일 목록, 커밋 메시지 템플릿, 테스트 사항
    *   목적: 간결한 기록, PR 본문 작성 시 활용
*   **커밋 메시지 규칙:**
    ```
    <type>: <subject>
    
    <body> (선택)
    
    타입:
    - feat: 새 기능 추가
    - fix: 버그 수정
    - docs: 문서 수정
    - refactor: 리팩토링
    - style: 코드 스타일 변경 (포맷팅 등)
    - test: 테스트 추가/수정
    - chore: 빌드/설정 변경
    
    예시:
    feat: 감정 캐릭터 UI 적용
    fix: AI 채팅 일기 라우팅 버그 수정
    docs: Gemini 프롬프트 가이드 업데이트
    ```
*   **브랜치 전략:**
    *   `main`: 안정 버전 (배포 가능)
    *   `develop`: 개발 중인 기능 통합
    *   `feature/<기능명>`: 새 기능 개발
    *   `fix/<버그명>`: 버그 수정
*   **PR(Pull Request) 규칙:**
    *   기능 완료 후 `develop`으로 PR 생성
    *   최소 1명의 리뷰 후 머지 (개인 프로젝트의 경우 셀프 리뷰)
    *   Conflict 해결 후 머지
*   **중요 파일 보호:**
    *   `.env` 파일은 절대 커밋하지 않음 (`.gitignore`에 포함 확인)
    *   `google-services.json`은 민감 정보 제거 후 커밋 고려

---

## 5. AI 협업 프로세스 (코드 품질 보장)

### 5.1 **코드 작성 전 필수 단계**

**모든 코드 작성/수정 요청 시 AI는 다음 순서를 따릅니다:**

1. **📖 문서 참조 (필수)**
   ```
   1) EMOTI_FLOW_DEVELOPMENT_PLAN.md 읽기
   2) 체크리스트 확인
   3) 위반 사항이 있으면 먼저 리팩토링 제안
   ```

2. **🔍 기존 코드 분석**
   ```
   1) 중복 코드 검색 (codebase_search)
   2) 파일 크기 확인 (200-300줄 기준)
   3) 공통 위젯/서비스 존재 여부 확인
   ```

3. **📐 설계 제안**
   ```
   1) Clean Architecture 계층 결정
   2) 위젯 분리 계획 수립
   3) 사용자에게 설계 승인 요청
   ```

4. **💻 코드 작성**
   ```
   1) const 생성자 최대한 활용
   2) 의미 있는 이름 사용
   3) 주석 추가
   ```

5. **✅ 사후 검증**
   ```
   1) 린트 에러 확인
   2) 파일 크기 재확인
   3) 체크리스트 준수 여부 보고
   ```

### 5.2 **협업 및 답변 규칙**

1.  **설계 우선:** 코드를 작성하기 전, 어떤 계층(Domain/Data/Presentation)을 수정할지, 왜 그런 구조를 선택했는지 설명합니다.
2.  **규칙 준수 보고:** 체크리스트 항목을 명시적으로 확인하고 보고합니다.
3.  **위반 시 즉시 알림:** 파일 크기가 300줄을 넘으면 즉시 리팩토링을 제안합니다.
4.  **테스트 코드 포함:** 새로운 기능을 구현할 때 해당 기능의 정상 작동을 보장하는 테스트 코드를 함께 제안합니다.
5.  **실무자 관점:** 포트폴리오 및 배포를 고려하여 예외 처리, 성능 최적화, 보안(API Key 관리 등)에 대해 조언합니다.

---

## 4. 추가 제안 사항 (Point 5)

*   **문서화 추가 요소:**
    *   **Architecture Diagram:** 현재 구조 시각화
    *   **API Specification:** Gemini 및 Firebase 연동 규격서
    *   **Test Report:** 테스트 커버리지 및 결과 문서화
*   **기능 보완:**
    *   **감정 통계 대시보드:** 주간/월간 감정 변화 리포트 (시각화 강화)
    *   **데이터 백업/복구:** 사용자 데이터를 안전하게 보호하는 로직 강화
    *   **접근성 및 인터랙션:** 더 유려한 애니메이션과 UX 디테일 개선

